#load entities
#load utils::math
#load gfx::{colour, context}

type Foo s32;

func blah() s32;

func foo();

type rgb_colour (u8, u8, u8);

// do comments work?
/*
    why yes they do!
    /* and when they nest!
    */
*/

type s32eger_array [s32];
type ref_s32eger_array &[s32];
type s32eger_array [f32];

type blah struct {
    left struct {
        a s32,
        b s32,
    },
    right struct {
        a s32,
        b s32
    },
    prs32er_thing func(a s32, b s32) s32,
};

type data_block struct {
    data *void,
    length us32,
};

type some_trait trait {
    update func(),  
    render func(vsync bool) void,
};

func blah() s32 {
    
}

func (i *s32) func_ptr() {
    
}

func (i s32) func_on_primitive() {
    
}

type foo_bar struct {
    foo s32,
    baz s32,
    boo us32
};

type foo struct {
	foo s32,
};

func add() void {
	
}

func main() s32 {
	32 + 32;

    let person_data struct {
        name *u8,
        age us32,
    };

    let {pname, page} = person_data;

    let foo = func() {};

    func() {};

	let x = 69 - 69 / 32 << 5;
	let y = 22 + -33333 * 59595;
	let z;
	let foo s32;

	let baz us32;

    let testing union {
        a s32,
        b s32,
        c us32,
    };

    let x = baz;
    let blah s32;
    blah.func_on_primitive()[5 : 123];

    if 1 == 1 {
        while true {
            if 1 == 3 {

            } 
            else if 2 == 5 {

            } 
            else {

            }
        }
    }

    let x = eval {
        yield 69;
    };

    while 4 == 4 {

    }

    while true {
while true {
while true {
while true {
while true {
while true {
while true {
    while true {
while true {
while true {
while true {
while true {
while true {
while true {
    while true {
while true {
while true {
while true {
while true {
while true {
while true {

    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }

    if true {

    }

    loop {

    }

	if -69 == 3 {

	}
	else if 444 == 3 && 69 == 69 || 3 >= 21 {

	}
	else {
        return size_of(5 + 3 - 2);
	}

    defer 4 + 4;

	return 69;
}