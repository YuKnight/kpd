#load entities
#load utils::math
#load gfx::{colour, context}

type Foo int;

func blah() int;

func foo();

type rgb_colour (u8, u8, u8);

// do comments work?
/*
    why yes they do!
    /* and when they nest!
    */
*/

type integer_array [int];
type ref_integer_array &[int];
type integer_array [f32];

type blah struct {
    left struct {
        a int,
        b int,
    },
    right struct {
        a int,
        b int
    },
    printer_thing func(a int, b int) int,
};

type data_block struct {
    data *void,
    length uint,
};

type some_trait trait {
    update func(),  
    render func(vsync bool) void,
};

func blah() int {
    
}

func (i *int) func_ptr() {
    
}

func (i int) func_on_primitive() {
    
}

type foo_bar struct {
    foo int,
    baz int,
    boo uint
};

type foo struct {
	foo int,
};

func add() void {
	
}

func main() int {
	32 + 32;

    let person_data struct {
        name *u8,
        age uint,
    };

    let {pname, page} = person_data;

    let foo = func() {};

    func() {};

	let x = 69 - 69 / 32 << 5;
	let y = 22 + -33333 * 59595;
	let z;
	let foo int;

	let baz uint;

    let testing union {
        a int,
        b int,
        c uint,
    };

    let x = baz;
    let blah int;
    blah.func_on_primitive()[5 : 123];

    if 1 == 1 {
        while true {
            if 1 == 3 {

            } else if 2 == 5 {

            } else {

            }
        }
    }

    let x = eval {
        yield 69;
    };

    while 4 == 4 {

    }

    while true {
while true {
while true {
while true {
while true {
while true {
while true {
    while true {
while true {
while true {
while true {
while true {
while true {
while true {
    while true {
while true {
while true {
while true {
while true {
while true {
while true {

    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }

    if true {

    }

    loop {

    }

	if -69 == 3 {

	}
	else if 444 == 3 && 69 == 69 || 3 >= 21 {

	}
	else {
        return size_of(5 + 3 - 2);
	}

    defer 4 + 4;

	return 69;
}