#include <stdio.h>
#include <stdint.h>
#include <stdbool.h>
#include <collectc/array.h>

#define ARRAY_SIZEOF(x) (sizeof(x) / sizeof(x[0]))

#include "opcodes.h"
#include "krugvm.h"
#include "vthread.h"

static unsigned char program[] = {
	0x00, 0x29, 
	0x00, 0x2a, 
	0x00, 0x29,
	0x00, 0x2a,
	0x00, 0x29,
	0x00, 0x02, 0x00, 0x00, 0x00, 0x01,
	0x00, 0x02, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x02, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x02, 0x00, 0x00, 0x00, 0x01,
	0x00, 0x13,
	0x00, 0x2b,
	0x00, 0x13,
	0x00, 0x2f, 0x00, 0x00, 0x00, 0x0e,
	0x00, 0x31, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x02, 0x00, 0x00, 0x00, 0x01,
	0x00, 0x02, 0x00, 0x00, 0x00, 0x01,
	0x00, 0x13,
	0x00, 0x2f, 0x00, 0x00, 0x00, 0x13,
	0x00, 0x31, 0x00, 0x00, 0x00, 0x02,
	0x00, 0x02, 0x00, 0x00, 0x00, 0x01,
	0x00, 0x02, 0x00, 0x00, 0x00, 0x01,
	0x00, 0x02, 0x00, 0x00, 0x00, 0x02,
	0x00, 0x02, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x13,
	0x00, 0x2c,
	0x00, 0x13,
	0x00, 0x2f, 0x00, 0x00, 0x00, 0x1c,
	0x00, 0x31, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x02, 0x00, 0x00, 0x00, 0x01,
	0x00, 0x02, 0x00, 0x00, 0x00, 0x01,
	0x00, 0x02, 0x00, 0x00, 0x00, 0x02,
	0x00, 0x02, 0x00, 0x00, 0x00, 0x02,
	0x00, 0x13,
	0x00, 0x2b,
	0x00, 0x13,
	0x00, 0x2f, 0x00, 0x00, 0x00, 0x25,
	0x00, 0x31, 0x00, 0x00, 0x00, 0x02,
	0x00, 0x02, 0x00, 0x00, 0x00, 0x01,
	0x00, 0x02, 0x00, 0x00, 0x00, 0x01,
	0x00, 0x02, 0x00, 0x00, 0x00, 0x02,
	0x00, 0x02, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x13,
	0x00, 0x2b,
	0x00, 0x13,
	0x00, 0x2f, 0x00, 0x00, 0x00, 0x2e,
	0x00, 0x31, 0x00, 0x00, 0x00, 0x02,
	0x00, 0x2,
};

struct Execution_Engine {
	Array* frames;

	struct Virtual_Thread* main;
	struct Virtual_Thread* thread;

	unsigned char* program;
};

struct Virtual_Thread* 
make_thread(struct Execution_Engine* engine) {
	struct Virtual_Thread* new_thread = malloc(sizeof(*new_thread));
	new_thread->program_counter = 0;
	// init thread...

	array_add(engine->frames, new_thread);
	engine->thread = new_thread;

	return new_thread;
}

void 
initialise_engine(struct Execution_Engine* engine, unsigned char* program) {
	array_new(&engine->frames);
	engine->main = make_thread(engine);
	engine->program = program;
}

bool 
execute_program(size_t entry_addr, size_t instruction_count, unsigned char* program) {
	struct Execution_Engine engine;
	initialise_engine(&engine, program);

	printf("Executing %zd instructions\n", instruction_count);

	engine.thread->program_counter = entry_addr;
	while (engine.thread->program_counter < instruction_count) {
		unsigned char* next_opcode = &program[engine.thread->program_counter += sizeof(uint16_t)];
		uint16_t op_code = (next_opcode[0] << 8) | next_opcode[1];
		switch (op_code) {
			case ENTR: {
				printf("enter baby!\n");
				break;
			}
			default: {
				printf("unimplemented opcode %d\n", op_code);
				break;
			}
		}
	}
	return false;
}

int 
main() {
	printf("Hello, World!\n");
	execute_program(0, ARRAY_SIZEOF(program), program);
	return 0;
}